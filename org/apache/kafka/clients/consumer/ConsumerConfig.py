GROUP_ID_CONFIG = "String  \"group.id\""
MAX_POLL_RECORDS_CONFIG = "String  \"max.poll.records\""
MAX_POLL_INTERVAL_MS_CONFIG = "String  \"max.poll.interval.ms\""
SESSION_TIMEOUT_MS_CONFIG = "String  \"session.timeout.ms\""
HEARTBEAT_INTERVAL_MS_CONFIG = "String  \"heartbeat.interval.ms\""
BOOTSTRAP_SERVERS_CONFIG = "String  \"bootstrap.servers\""
ENABLE_AUTO_COMMIT_CONFIG = "String  \"enable.auto.commit\""
AUTO_COMMIT_INTERVAL_MS_CONFIG = "String  \"auto.commit.interval.ms\""
PARTITION_ASSIGNMENT_STRATEGY_CONFIG = "String  \"partition.assignment.strategy\""
AUTO_OFFSET_RESET_CONFIG = "String  \"auto.offset.reset\""
AUTO_OFFSET_RESET_DOC = "String  \"What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server (e.g. because that data has been deleted): <ul><li>earliest: automatically reset the offset to the earliest offset<li>latest: automatically reset the offset to the latest offset</li><li>none: throw exception to the consumer if no previous offset is found for the consumer's group</li><li>anything else: throw exception to the consumer.</li></ul>\""
FETCH_MIN_BYTES_CONFIG = "String  \"fetch.min.bytes\""
FETCH_MAX_BYTES_CONFIG = "String  \"fetch.max.bytes\""
DEFAULT_FETCH_MAX_BYTES = "int  52428800"
FETCH_MAX_WAIT_MS_CONFIG = "String  \"fetch.max.wait.ms\""
METADATA_MAX_AGE_CONFIG = "String  \"metadata.max.age.ms\""
MAX_PARTITION_FETCH_BYTES_CONFIG = "String  \"max.partition.fetch.bytes\""
DEFAULT_MAX_PARTITION_FETCH_BYTES = "int  1048576"
SEND_BUFFER_CONFIG = "String  \"send.buffer.bytes\""
RECEIVE_BUFFER_CONFIG = "String  \"receive.buffer.bytes\""
CLIENT_ID_CONFIG = "String  \"client.id\""
RECONNECT_BACKOFF_MS_CONFIG = "String  \"reconnect.backoff.ms\""
RECONNECT_BACKOFF_MAX_MS_CONFIG = "String  \"reconnect.backoff.max.ms\""
RETRY_BACKOFF_MS_CONFIG = "String  \"retry.backoff.ms\""
METRICS_SAMPLE_WINDOW_MS_CONFIG = "String  \"metrics.sample.window.ms\""
METRICS_NUM_SAMPLES_CONFIG = "String  \"metrics.num.samples\""
METRICS_RECORDING_LEVEL_CONFIG = "String  \"metrics.recording.level\""
METRIC_REPORTER_CLASSES_CONFIG = "String  \"metric.reporters\""
CHECK_CRCS_CONFIG = "String  \"check.crcs\""
KEY_DESERIALIZER_CLASS_CONFIG = "String  \"key.deserializer\""
KEY_DESERIALIZER_CLASS_DOC = "String  \"Deserializer class for key that implements the <code>org.apache.kafka.common.serialization.Deserializer</code> interface.\""
VALUE_DESERIALIZER_CLASS_CONFIG = "String  \"value.deserializer\""
VALUE_DESERIALIZER_CLASS_DOC = "String  \"Deserializer class for value that implements the <code>org.apache.kafka.common.serialization.Deserializer</code> interface.\""
CONNECTIONS_MAX_IDLE_MS_CONFIG = "String  \"connections.max.idle.ms\""
REQUEST_TIMEOUT_MS_CONFIG = "String  \"request.timeout.ms\""
INTERCEPTOR_CLASSES_CONFIG = "String  \"interceptor.classes\""
INTERCEPTOR_CLASSES_DOC = "String  \"A list of classes to use as interceptors. Implementing the <code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code> interface allows you to intercept (and possibly mutate) records received by the consumer. By default, there are no interceptors.\""
EXCLUDE_INTERNAL_TOPICS_CONFIG = "String  \"exclude.internal.topics\""
DEFAULT_EXCLUDE_INTERNAL_TOPICS = "boolean  true"
ISOLATION_LEVEL_CONFIG = "String  \"isolation.level\""
ISOLATION_LEVEL_DOC = "String  \"<p>Controls how to read messages written transactionally. If set to <code>read_committed</code>, consumer.poll() will only return transactional messages which have been committed. If set to <code>read_uncommitted</code>' (the default), consumer.poll() will return all messages, even transactional messages which have been aborted. Non-transactional messages will be returned unconditionally in either mode.</p> <p>Messages will always be returned in offset order. Hence, in  <code>read_committed</code> mode, consumer.poll() will only return messages up to the last stable offset (LSO), which is the one less than the offset of the first open transaction. In particular any messages appearing after messages belonging to ongoing transactions will be withheld until the relevant transaction has been completed. As a result, <code>read_committed</code> consumers will not be able to read up to the high watermark when there are in flight transactions.</p><p> Further, when in <code>read_committed</mode> the seekToEnd method will return the LSO\""
def ():
    '''returns ConsumerConfig\n\n
    (final Properties props)\n
    (final Map<String, Object> props)\n
    '''
